import express from "express";
import path from "path";
import { fileURLToPath } from "url";
import { Worker } from "worker_threads";

import { normalizeUrl, TTLCache, RateLimiter, jsonError } from "./api_hardening.js";

const app = express();
app.use(express.json());

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// ===== Config =====
const FRONTEND_DIST = path.join(__dirname, "frontend", "dist");

// Demo rate limit (per IP)
const demoLimiter = new RateLimiter({ windowMs: 10 * 60 * 1000, max: 3 }); // 3 audits / 10 min
// Cache (per normalized URL)
const auditCache = new TTLCache({ ttlMs: 10 * 60 * 1000, maxEntries: 300 }); // 10 min

// Job store (in-memory for now; swap to Redis later)
const jobs = new Map(); // jobId -> { status, data?, error?, createdAt }
const JOB_TTL_MS = 30 * 60 * 1000;

function makeId() {
  return Math.random().toString(16).slice(2) + Date.now().toString(16);
}

function getClientIp(req) {
  const xf = req.headers["x-forwarded-for"];
  if (typeof xf === "string" && xf.length) return xf.split(",")[0].trim();
  return req.socket?.remoteAddress || "unknown";
}

setInterval(() => {
  const now = Date.now();
  for (const [id, j] of jobs.entries()) {
    if (now - (j.createdAt || now) > JOB_TTL_MS) jobs.delete(id);
  }
}, 60 * 1000).unref();

// ===== API =====
app.get("/api/health", (req, res) => res.json({ ok: true }));

app.post("/api/reset-demo", (req, res) => {
  // Keep for future DB-based demo resets; currently frontend-only reset is enough.
  res.json({ ok: true });
});

// Create audit job
app.post("/api/audit", (req, res) => {
  const ip = getClientIp(req);

  const urlRaw = req.body?.url;
  const v = normalizeUrl(urlRaw);
  if (!v.ok) return jsonError(res, 400, v.code, v.message);

  const targetUrl = v.normalized;

  const rl = demoLimiter.hit(ip);
  if (!rl.allowed) {
    res.setHeader("Retry-After", Math.ceil((rl.resetAt - Date.now()) / 1000));
    return jsonError(res, 429, "RATE_LIMITED", "Demo rate limit reached. Try again later.", { resetAt: rl.resetAt });
  }

  const cached = auditCache.get(targetUrl);
  const jobId = makeId();

  if (cached) {
    jobs.set(jobId, { status: "done", data: cached, createdAt: Date.now() });
    return res.json({ ok: true, jobId, cached: true });
  }

  jobs.set(jobId, { status: "running", createdAt: Date.now() });
  res.json({ ok: true, jobId, cached: false });

  const worker = new Worker(new URL("./audit_worker.js", import.meta.url), { type: "module" });

  const killTimer = setTimeout(() => {
    try { worker.terminate(); } catch {}
    jobs.set(jobId, { status: "error", error: { code: "TIMEOUT", message: "Audit timed out." }, createdAt: Date.now() });
  }, 15000);

  worker.on("message", (msg) => {
    clearTimeout(killTimer);
    try { worker.terminate(); } catch {}

    if (msg?.ok) {
      auditCache.set(targetUrl, msg.data);
      jobs.set(jobId, { status: "done", data: msg.data, createdAt: Date.now() });
    } else {
      jobs.set(jobId, { status: "error", error: msg.error || { code: "FAILED", message: "Audit failed" }, createdAt: Date.now() });
    }
  });

  worker.on("error", (err) => {
    clearTimeout(killTimer);
    try { worker.terminate(); } catch {}
    jobs.set(jobId, { status: "error", error: { code: "WORKER_CRASH", message: "Worker crashed.", detail: String(err?.message || err) }, createdAt: Date.now() });
  });

  worker.postMessage({ jobId, url: targetUrl });
});

// Poll job
app.get("/api/audit/:jobId", (req, res) => {
  const j = jobs.get(req.params.jobId);
  if (!j) return jsonError(res, 404, "JOB_NOT_FOUND", "Job not found.");

  if (j.status === "done") return res.json({ ok: true, status: "done", data: j.data });
  if (j.status === "error") return res.status(400).json({ ok: false, status: "error", error: j.error });
  return res.json({ ok: true, status: j.status });
});

// ===== Static frontend (single-port) =====
app.use(express.static(FRONTEND_DIST));
app.get("*", (req, res) => res.sendFile(path.join(FRONTEND_DIST, "index.html")));

const port = process.env.PORT || 3000;
app.listen(port, () => console.log(`Frontend running on port ${port}`));
